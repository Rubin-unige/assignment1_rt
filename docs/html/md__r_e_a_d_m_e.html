<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Research Trach Assignment I: Research Track I - First Assignment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Research Trach Assignment I
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Research Track I First Assignment - ROS TurtleSim Control &amp; Monitoring</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Research Track I - First Assignment </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This repository contains the assignment work for the <b>Research Track</b> course, completed by: <br  />
 <b>Rubin Khadka Chhetri</b> <br  />
 <b>ID: 6558048</b></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#node-details">Node Details</a><ul>
<li><a href="#1-user-interface-node-user_interface">User Interface Node</a></li>
<li><a href="#2-distance-monitor-node-distance_monitor">Distance Monitor Node</a></li>
</ul>
</li>
<li><a href="#repository-structure">Repository Structure</a></li>
<li><a href="#getting-started-read-before-action">Getting Started (Read Before Action)</a><ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#setup">Setup</a></li>
</ul>
</li>
<li><a href="#launching-simulation-and-nodes">Launching Simulation and Nodes</a><ul>
<li><a href="#running-the-c-version">Running C++ version</a></li>
<li><a href="#running-the-python-version">Running Python version</a></li>
<li><a href="#alternative-configurations">Alternative Configurations</a></li>
</ul>
</li>
<li><a href="#implementation-details">Implementation Details</a><ul>
<li><a href="#user-interface-node">User Interface Node</a></li>
<li><a href="#distance-monitor-node">Distance Monitor Node</a></li>
</ul>
</li>
<li><a href="#summary">Summary</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p>This repository implements a ROS package containing two main nodes:</p>
<ul>
<li><b>User Interface node</b></li>
<li><b>Distance Monitor node</b></li>
</ul>
<p>These nodes work together within the **<code>turtlesim</code>** simulation environment to create a simple, interactive system for controlling and monitoring two turtles.</p>
<p><em><b>Note:</b></em>:</p><ul>
<li>This assignment is completed using both <b>Python</b> and <b>C++</b>.</li>
<li>Custom message is included in this project, which is not required. The turtles distance is published in the <code>turtle_distance_topic</code> using this custom message. It good for further development.</li>
</ul>
<h1><a class="anchor" id="autotoc_md3"></a>
Node Details</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
1. User Interface Node (user_interface)</h2>
<p>This node is responsible for handling user input and controlling the movements of two turtles (<code>turtle1</code> and <code>turtle2</code>) in the simulator. Its key functions include:</p><ul>
<li>Spawns a second turtle (<code>turtle2</code>) in the simulation environment.</li>
<li>Prompts the user to:<ul>
<li>Select which turtle to control (either <code>turtle1</code> or <code>turtle2</code>).</li>
<li>Set the selected turtle's linear and angular velocities.</li>
</ul>
</li>
<li>Sends movement commands to the selected turtle, causing it to move for one second. After the movement, the turtle stops, and the interface is ready to accept the next command.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
2. Distance Monitor Node (distance_monitor)</h2>
<p>This node ensures that the turtles maintain safe distances from each other and stay within the boundaries of the simulation environment. This node continuously calculates and monitors turtle positions. Its key features are:</p><ul>
<li>Continuously calculates the distance between <code>turtle1</code> and <code>turtle2</code> and publishes this information on a dedicated ROS topic for monitoring.</li>
<li>Automatically stops a turtle if it approaches the other turtle.</li>
<li>Stops a turtle if it's position is too close to the boundaries.</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
Repository Structure</h1>
<p>The root of this repository is the package folder, which contains all necessary files and scripts for running the assignment nodes. When cloning the repository for the first time, place it directly in the <code>src</code> folder of your ROS workspace.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Folder and File Overview</h2>
<ul>
<li>**<code>/msg</code>**: Contains custom message definitions.<ul>
<li><code>turtle_distance.msg</code>: Custom message file for distance monitoring and boundary status. Contains <code>float32 distance</code> msg which is required to publish distance to <code>turtle_distance_topic</code>.</li>
</ul>
</li>
<li>**<code>/scripts</code>**: Contains Python scripts used for the nodes in this project.<ul>
<li><code><a class="el" href="user__interface_8py.html">user_interface.py</a></code>: Python version of user interface node.</li>
<li><code><a class="el" href="distance__monitor_8py.html">distance_monitor.py</a></code>: Python version of distance monitor node.</li>
</ul>
</li>
<li>**<code>/src</code>**: Contains C++ source files.<ul>
<li><code><a class="el" href="user__interface_8cpp.html" title="This node provides a user interface for controlling turtles in the turtlesim environment.">user_interface.cpp</a></code>: C++ version of the user interface node.</li>
<li><code><a class="el" href="distance__monitor_8cpp.html" title="This node monitors the distance between two turtles and checks if they are near boundaries.">distance_monitor.cpp</a></code>: C++ version of the distance monitor node.</li>
</ul>
</li>
<li>**<code>/CMakeLists.txt</code>**: Specifies the package build rules.</li>
<li>**<code>/package.xml</code>**: Lists dependencies and package metadata.</li>
<li>**<code>/README.md</code>**: This file (Documentation).</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Getting Started (Read Before Action)</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Prerequisites</h2>
<p>Before proceeding, make sure that **<code>ROS Noetic</code>** is installed on your system.<br  />
 If you haven’t set up ROS yet, check this official guide to install ROS: <br  />
 (<a href="https://wiki.ros.org/noetic/Installation/Ubuntu">https://wiki.ros.org/noetic/Installation/Ubuntu</a>) <br  />
</p>
<p>Additionally, you’ll need **<code>Python 3</code>** and **<code>turtlesim</code>** package to run this project. Ensure they are installed on your system. If not, you can install them by running: </p><div class="fragment"><div class="line">sudo apt-get update</div>
<div class="line">sudo apt-get install ros-noetic-turtlesim</div>
<div class="line">sudo apt-get install python3</div>
</div><!-- fragment --><p>After installation, you can proceed to cloning the repository.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Setup</h2>
<h3><a class="anchor" id="autotoc_md11"></a>
1. Set up your ROS workspace</h3>
<p>Create a new workspace (or use an existing one) and navigate to its <code>src</code> directory: </p><div class="fragment"><div class="line">mkdir -p ~/my_new_ws/src</div>
<div class="line">cd ~/my_new_ws/src</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
2. Clone this repository</h3>
<p>Clone the assignment repository into your workspace’s <code>src</code> folder: </p><div class="fragment"><div class="line">git clone https://github.com/Rubin-unige/assignment1_rt.git</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
3. Add the Workspace to Your ROS Environment</h3>
<p>To ensure that your workspace is sourced automatically every time you start a new terminal session, add it to your <code>.bashrc</code> file: </p><div class="fragment"><div class="line">echo &quot;source ~/my_new_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</div>
<div class="line">source ~/.bashrc</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
4. Build the Package</h3>
<p>Navigate to the root of your workspace and build the package using <code>catkin_make</code>: </p><div class="fragment"><div class="line">cd ~/my_new_ws</div>
<div class="line">catkin_make</div>
</div><!-- fragment --><p>After building, your workspace will be ready to launch the nodes in the package.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Launching Simulation and Nodes</h1>
<h3><a class="anchor" id="autotoc_md16"></a>
1. Start the ROS Master</h3>
<p>Before running any ROS nodes, make sure the ROS Master is up and running. Open a terminal and start <code>roscore</code>: </p><div class="fragment"><div class="line">roscore</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md17"></a>
2. Run the Turtlesim Node</h3>
<p>Next, start the <code>Turtlesim</code> node in a new terminal to launch the simulation environment: </p><div class="fragment"><div class="line">rosrun turtlesim turtlesim_node</div>
</div><!-- fragment --><p>This will open the Turtlesim window where the turtles (<code>turtle1</code> and <code>turtle2</code>) will appear.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
3. Run the User Interface and Distance Monitor Nodes</h3>
<p>At this point, you can proceed to run either the <b>C++</b> or <b>Python</b> version of the <code>User Interface</code> and <code>Distance Monitor</code> nodes, depending on which implementation you want to use. The nodes can be run individually or in combination, offering flexibility in how you choose to execute them.</p>
<h1><a class="anchor" id="autotoc_md19"></a>
#### Running the C++ Version</h1>
<p>To run the C++ nodes, follow these steps:</p><ul>
<li>Make sure that the <code>roscore</code> and <code>turtlesim</code> nodes are running.</li>
<li>In a new terminal, run the <b>C++ User Interface Node</b>: <div class="fragment"><div class="line">rosrun assignment1_rt user_interface</div>
</div><!-- fragment --></li>
<li>In another terminal, run the <b>C++ Distance Monitor Node</b>: <div class="fragment"><div class="line">rosrun assignment1_rt distance_monitor</div>
</div><!-- fragment --></li>
</ul>
<p>This will start both the <b>C++ user interface</b> for controlling the turtles and the <b>distance monitor</b> to track their movements.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
#### Running the Python Version</h1>
<p>To run the Python nodes, follow these steps:</p><ul>
<li>Make sure that the <code>roscore</code> and <code>turtlesim</code> nodes are running.</li>
<li>Make the <b>Python scripts executable</b></li>
</ul>
<p>Before running the Python scripts, you need to ensure they are executable. Run the following command for each Python script (<code><a class="el" href="user__interface_8py.html">user_interface.py</a></code> and <code><a class="el" href="distance__monitor_8py.html">distance_monitor.py</a></code>): </p><div class="fragment"><div class="line">chmod +x ~/my_new_ws/src/assignment1_rt/scripts/user_interface.py</div>
<div class="line">chmod +x ~/my_new_ws/src/assignment1_rt/scripts/distance_monitor.py</div>
</div><!-- fragment --><ul>
<li>After making the scripts executable, run the <b>Python User Interface Node</b> in the same terminal: <div class="fragment"><div class="line">rosrun assignment1_rt user_interface.py</div>
</div><!-- fragment --></li>
<li>Open a new terminal and run the <b>Python Distance Monitor Node</b>: <div class="fragment"><div class="line">rosrun assignment1_rt distance_monitor.py</div>
</div><!-- fragment --></li>
</ul>
<p>This will start both the <b>Python user interface</b> for controlling the turtles and the <b>distance monitor</b> to track their movements.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
#### Alternative Configurations</h1>
<p>The program is flexible, allowing you to mix and match the <b>C++</b> and <b>Python</b> nodes based on your preference. For example, you can run the <code>C++ User Interface</code> node while running the <code>Python Distance Monitor</code> node, or vice versa. This allows you to run the system in the configuration that best suits your workflow and testing needs.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
4. Stopping the nodes</h3>
<p>To stop the nodes, simply press <code>Ctrl+C</code> in the terminal where each node is running (<code>User Interface</code>, <code>Distance Monitor</code>, <code>Turtlesim</code>, or <code>roscore</code>). This will terminate the nodes and stop the simulation.</p>
<h1><a class="anchor" id="autotoc_md23"></a>
Implementation Details</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
User Interface Node</h2>
<p>The structure of the <code><a class="el" href="namespaceuser__interface.html">user_interface</a></code> node is similar in both <b>C++</b> and <b>Python</b>. The logic for handling user inputs, setting velocities, and publishing commands is nearly identical in both languages. Since the logic for both versions is fundamentally the same, I will explain the details using the <b>C++</b> version as an example.</p>
<p>However, there was one key difference when running the node in <b>Python</b>: if the user closed the node and opened it again, <code>turtle2</code> would already exist in the simulation, causing a conflict. This issue did not occur in the <b>C++</b> implementation, where if <code>turtle2</code> already existed, the node would simply display a message saying "turtle2 already exists" and take the position from the already existing turtle.</p>
<p>In the <b>Python</b> version, when the node is restarted, attempting to spawn <code>turtle2</code> again would cause the node to crash because <code>turtle2</code> already existed in the simulation. To address this, additional checks were implemented to ensure that <code>turtle2</code> is only spawned if it doesn't already exist. This solution is explained below in separate section.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
1. Spawning Turtle2</h2>
<p>The <code><a class="el" href="namespaceuser__interface.html">user_interface</a></code> node automatically spawns a second turtle, <code>turtle2</code>, in the simulation when the program starts. This is accomplished using the <code>/spawn</code> service provided by <code>turtlesim</code>, which allows for creating a new turtle at a specified position and orientation in the simulation environment.</p>
<p>In this implementation:</p>
<ul>
<li><code>turtle2</code> is spawned at coordinates **(5.0, 2.0)** with an orientation of <b>0.0</b> radians, positioning it to face directly to the right.</li>
<li>The <code>/spawn</code> service is called during the initialization phase of the node, ensuring that <code>turtle2</code> is added automatically without requiring any user input.</li>
</ul>
<p>Below is the code that sets up the spawn request: </p><div class="fragment"><div class="line"><span class="comment">// Initialise service clients</span></div>
<div class="line">ros::ServiceClient client_spawn = nh.serviceClient &lt;turtlesim::Spawn&gt; (<span class="stringliteral">&quot;/spawn&quot;</span>);</div>
<div class="line">turtlesim::Spawn spawn_srv;</div>
<div class="line"><span class="comment">// Spawn Turtle</span></div>
<div class="line">spawn_srv.request.x = 5.0;</div>
<div class="line">spawn_srv.request.y = 2.0;</div>
<div class="line">spawn_srv.request.theta = 0.0;</div>
<div class="line">spawn_srv.request.name = <span class="stringliteral">&quot;turtle2&quot;</span>;</div>
<div class="line">client_spawn.call(spawn_srv);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
2. User Interface</h2>
<p>The user interface of the <code><a class="el" href="namespaceuser__interface.html">user_interface</a></code> node allows the user to control either <code>turtle1</code> or <code>turtle2</code> by setting their velocities.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
1. Selecting the Turtle</h3>
<p>The user is prompted to select a turtle (either <code>turtle1</code> or <code>turtle2</code>). If an invalid input is provided, the program will re-prompt the user until a valid turtle name is entered</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the turtle you want to control (turtle1 or turtle2): &quot;</span>;</div>
<div class="line">std::cin &gt;&gt; turtle_name;</div>
<div class="line"><span class="keywordflow">if</span> (turtle_name != <span class="stringliteral">&quot;turtle1&quot;</span> &amp;&amp; turtle_name != <span class="stringliteral">&quot;turtle2&quot;</span>) {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid turtle name. Please enter &#39;turtle1&#39; or &#39;turtle2&#39;.\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">continue</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28"></a>
2. Setting Velocities</h3>
<p>After selecting a turtle, the user is asked to enter the linear and angular velocities. Error handling ensures only valid numeric inputs are accepted.</p>
<ul>
<li>Linear Velocity (x):<br  />
 The user is prompted for the linear velocity. If the input is invalid, the program clears the error state and asks the user to re-enter a valid value. <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the linear velocity x (between -5 and 5): &quot;</span>;</div>
<div class="line"><span class="keywordflow">while</span> (!(std::cin &gt;&gt; <a class="code" href="user__interface_8cpp.html#a6ef24e69b57370abcf35b40ec777f18f">linear_x</a>) || linear_x &lt; -5 || linear_x &gt; 5) { </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid input. Please enter a linear velocity between -5 and 5: &quot;</span>;</div>
<div class="line">    std::cin.clear(); <span class="comment">// Clear error</span></div>
<div class="line">    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Angular Velocity (z):<br  />
 The same process is repeated for the angular velocity input. <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Enter the angular velocity z (between -5 and 5): &quot;</span>;</div>
<div class="line"><span class="keywordflow">while</span> (!(std::cin &gt;&gt; <a class="code" href="user__interface_8cpp.html#afa644bf33e0fb93ec0f706746816bbcd">angular_z</a>) || angular_z &lt; -5 || angular_z &gt; 5) { </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid input. Please enter an angular velocity between -5 and 5: &quot;</span>;</div>
<div class="line">    std::cin.clear(); <span class="comment">// Clear error</span></div>
<div class="line">    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md29"></a>
Error Handling Issue</h3>
<ul>
<li><b>Invalid user input issue</b></li>
</ul>
<p>During the initial implementation of the node, I faced an issue with invalid inputs for the velocities. If the user entered a non-numeric value, the program would crash or behave unexpectedly. To resolve this, I added error handling that clears the input buffer and prompts the user to re-enter valid values for both the linear and angular velocities.</p>
<ul>
<li><b>Overshoot Issue</b></li>
</ul>
<p>While running the distance monitor node, I encountered the overshoot issue, which is explained in more detail in the <a href="#6-check-and-handle-the-overshoot-issue">Overshoot Issue</a> section. One of the solutions to this problem was to constrain the velocities the user can input, thereby giving the program enough time to process the information. As shown in the code above, users are only allowed to enter velocities between <b>-5</b> and <b>5</b>, which helps to prevent the turtle from moving too quickly and overshooting the boundary.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
3. Publishing User Input</h2>
<p>Once the user has selected the turtle and entered the linear and angular velocities, the <code><a class="el" href="namespaceuser__interface.html">user_interface</a></code> node publishes these commands to the respective turtle's velocity topic.</p>
<p>The following steps are taken to publish the user inputs:</p>
<h3><a class="anchor" id="autotoc_md31"></a>
1. Turtle Selection</h3>
<p>After the user selects the turtle, the node checks which turtle was selected and publishes the corresponding velocity commands to the respective topic.</p><ul>
<li><code>turtle1</code> uses the topic <code>/turtle1/cmd_vel</code>.</li>
<li><code>turtle2</code> uses the topic <code>/turtle2/cmd_vel</code>. <div class="fragment"><div class="line">ros::Publisher <a class="code" href="distance__monitor_8cpp.html#aca10e25faa94589e8f7dc10845abd1a0">pub_turtle1</a> = nh.advertise &lt;geometry_msgs::Twist&gt;(<span class="stringliteral">&quot;/turtle1/cmd_vel&quot;</span>, 10);</div>
<div class="line">ros::Publisher <a class="code" href="distance__monitor_8cpp.html#a2beb12dd3123424a31990aebcd23133c">pub_turtle2</a> = nh.advertise &lt;geometry_msgs::Twist&gt;(<span class="stringliteral">&quot;/turtle2/cmd_vel&quot;</span>, 10);</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md32"></a>
2. Publishing the Velocity Command</h3>
<p>A <code>geometry_msgs::Twist</code> message is created, which holds the linear and angular velocities. This message is then published to the appropriate topic using the publisher.</p>
<p>Below is the code for publishing the velocities: </p><div class="fragment"><div class="line">geometry_msgs::Twist turtle_vel;</div>
<div class="line">turtle_vel.linear.x = <a class="code" href="user__interface_8cpp.html#a6ef24e69b57370abcf35b40ec777f18f">linear_x</a>;</div>
<div class="line">turtle_vel.angular.z = <a class="code" href="user__interface_8cpp.html#afa644bf33e0fb93ec0f706746816bbcd">angular_z</a>;</div>
<div class="line"><span class="keywordflow">if</span> (turtle_name == <span class="stringliteral">&quot;turtle1&quot;</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="distance__monitor_8cpp.html#aca10e25faa94589e8f7dc10845abd1a0">pub_turtle1</a>.publish(turtle_vel);</div>
<div class="line">  ros::Duration(1.0).sleep();</div>
<div class="line">  turtle_vel.linear.x = 0.0;</div>
<div class="line">  turtle_vel.angular.z = 0.0;</div>
<div class="line">  <a class="code" href="distance__monitor_8cpp.html#aca10e25faa94589e8f7dc10845abd1a0">pub_turtle1</a>.publish(turtle_vel);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (turtle_name == <span class="stringliteral">&quot;turtle2&quot;</span>) {</div>
<div class="line">  <a class="code" href="distance__monitor_8cpp.html#a2beb12dd3123424a31990aebcd23133c">pub_turtle2</a>.publish(turtle_vel);  </div>
<div class="line">  ros::Duration(1.0).sleep();    </div>
<div class="line">  turtle_vel.linear.x = 0;         </div>
<div class="line">  turtle_vel.angular.z = 0;</div>
<div class="line">  <a class="code" href="distance__monitor_8cpp.html#a2beb12dd3123424a31990aebcd23133c">pub_turtle2</a>.publish(turtle_vel); </div>
<div class="line">} </div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md33"></a>
Explanation of the Code</h3>
<ul>
<li><code>geometry_msgs::Twist turtle_vel;</code>: This message holds the velocity commands for the turtle. The <code>linear.x</code> field holds the linear velocity, and <code>angular.z</code> holds the angular velocity.</li>
<li><code>turtle_vel.linear.x = linear_x;</code> and <code>turtle_vel.angular.z = angular_z;</code>: These lines set the user-defined velocities for linear and angular movement.</li>
<li><code>pub_turtle1.publish(turtle_vel);</code> and <code>pub_turtle2.publish(turtle_vel);</code>: Depending on the selected turtle, the program publishes the velocity message to the appropriate topic (<code>/turtle1/cmd_vel</code> or <code>/turtle2/cmd_vel</code>).</li>
<li><code>ros::Duration(1.0).sleep();</code>: This command pauses the program for 1 second, allowing the turtle to move. <code>ros::Duration(1.0).sleep()</code> is used instead of <code>sleep(1.0)</code> because it is specifically designed for ROS nodes, ensuring proper synchronization with the ROS event loop and preventing any timing issues.</li>
</ul>
<h3><a class="anchor" id="autotoc_md34"></a>
3. Stopping the Turtle</h3>
<p>After 1 second, the velocities are set to 0 (both linear and angular) to stop the turtle, and the stop command is published to the respective turtle.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
4. Python &lt;tt&gt;turtle2&lt;/tt&gt; already exist issue</h2>
<p>As discussed earlier, when restarting the <code><a class="el" href="namespaceuser__interface.html">user_interface</a></code> node in <b>Python</b>, the node crashed because <code>turtle2</code> already existed in the simulation. This issue did not occur in the <b>C++</b> version.</p>
<p>To address this problem in <b>Python</b>, an additional check was implemented to ensure that <code>turtle2</code> already exists in the simulation before attempting to spawn it. This check uses the <code>/turtle2/pose</code> topic, which is only active when <code>turtle2</code> is present. The solution involves the following steps:</p>
<ul>
<li>Check if <code>turtle2</code> Exists:<ul>
<li>Subscribe to the <code>/turtle2/pose</code> topic, which publishes the position and orientation of <code>turtle2</code>.</li>
<li>If a message is received within a 1-second timeout, it confirms that <code>turtle2</code> already exists in the simulation, and no further action is needed.</li>
</ul>
</li>
<li>Spawn <code>turtle2</code> if Not Found:<ul>
<li>If no message is received within the timeout, the node assumes that <code>turtle2</code> does not exist.</li>
<li>The node then calls the <code>/spawn</code> service to create <code>turtle2</code> at the coordinates **(5.0, 2.0)** with an orientation of <b>0.0</b>.</li>
</ul>
</li>
</ul>
<p>Below is the code that sets up this check: </p><div class="fragment"><div class="line">def check_if_turtle2_exists():</div>
<div class="line">  ## Checks if turtle2 exists by subscribing to /turtle2/pose.</div>
<div class="line">  turtle2_exists = False</div>
<div class="line">  def pose_callback(msg):</div>
<div class="line">      nonlocal turtle2_exists</div>
<div class="line">      turtle2_exists = True  # Message received; turtle2 exists</div>
<div class="line">  # Subscribe to /turtle2/pose topic</div>
<div class="line">  rospy.Subscriber(&#39;/turtle2/pose&#39;, Pose, pose_callback)</div>
<div class="line">  # Short delay , wait message</div>
<div class="line">  timeout_time = rospy.Time.now() + rospy.Duration(1.0)  # 1-second timeout</div>
<div class="line">  while rospy.Time.now() &lt; timeout_time and not rospy.is_shutdown():</div>
<div class="line">      rospy.sleep(0.1)  # Sleep in small increments</div>
<div class="line">  return turtle2_exists</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md37"></a>
Distance Monitor Node</h2>
<p>Similar to <code>user interface</code> node, the <code>Distance Monitor</code> Node shares a similar structure in both <b>Python</b> and <b>C++</b>, with the core logic remaining consistent across both implementations. I will use the <b>C++</b> version as the primary example to explain the implementation.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
1. Set boundary conditions</h2>
<p>In <code>turtlesim</code>, the window has predefined coordinates where the turtles' positions are constrained. The boundary conditions are essential to keep the turtles within the window and avoid collisions. The following conditions are defined:</p>
<ul>
<li><b>boundary_limit</b>: This is the minimum allowed position (in both the x and y directions). If the turtle's position gets close to this limit, it is considered near the boundary. Here it is set to 1.0.</li>
<li><b>max_limit</b>: This is the maximum allowed position for a turtle. If the turtle exceeds this limit, it is considered out of bounds, and corrective actions should be taken. Here it is set to 10.0.</li>
<li><b>distance_threshold</b>: This defines the minimum safe distance between the two turtles. If the turtles get closer than this distance, they are considered to be too close and need to be stopped to avoid collision. Here it is set to 2.0. <div class="fragment"><div class="line"><span class="comment">// Global variables to store turtle positions</span></div>
<div class="line"><span class="keywordtype">float</span> <a class="code" href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a>, <a class="code" href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a>, <a class="code" href="distance__monitor_8cpp.html#a18b4c1bf1df6ad90f1e236bd496387f4">turtle2_x</a>, <a class="code" href="distance__monitor_8cpp.html#aa22dc3f61e7b2c48e0761801e1f124bf">turtle2_y</a>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="distance__monitor_8cpp.html#aa1ac8686414dbfefaeac118fff7d3ebb">distance_threshold</a> = 2.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="distance__monitor_8cpp.html#a8fae504c5b5982cecffc3c82190a1f29">boundary_limit</a> = 1.0;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> <a class="code" href="distance__monitor_8cpp.html#a878bf73af4e66301337cd71ff79f622c">max_limit</a> = 10.0;</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md39"></a>
2. Calculate the distance between two turtles</h2>
<p>To calculate the distance between two turtles, the <b>Euclidean distance</b> formula is used. This formula determines the straight-line distance between two points in a 2D space based on their <b>x</b> and <b>y</b> coordinates. The formula is:</p>
<p>$$ distance = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$</p>
<p>Where:</p><ul>
<li>$( (x_1, y_1) )$ are the coordinates of turtle1,</li>
<li>$( (x_2, y_2) )$ are the coordinates of turtle2.</li>
</ul>
<p>This calculation helps in monitoring whether the turtles are too close to each other, based on the <b>distance_threshold</b>. </p><div class="fragment"><div class="line"><span class="comment">// Calculate the distance between turtles</span></div>
<div class="line"><span class="keywordtype">float</span> distance = sqrt(pow(<a class="code" href="distance__monitor_8cpp.html#a18b4c1bf1df6ad90f1e236bd496387f4">turtle2_x</a> - <a class="code" href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a>, 2) + pow(<a class="code" href="distance__monitor_8cpp.html#aa22dc3f61e7b2c48e0761801e1f124bf">turtle2_y</a> - <a class="code" href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a>, 2));</div>
</div><!-- fragment --><p>Now, to perform this calculation, we need the <b>x</b> and <b>y</b> values for both turtles. These values are retrieved by subscribing to the <code>/turtle1/pose</code> and <code>/turtle2/pose</code> topics. Each turtle continuously publishes its position in the <b>Pose</b> message format, which includes the <b>x</b> and <b>y</b> coordinates. </p><div class="fragment"><div class="line"><span class="comment">// Subscribers for turtle positions</span></div>
<div class="line">ros::Subscriber sub_turtle1 = nh.subscribe(<span class="stringliteral">&quot;/turtle1/pose&quot;</span>, 10, <a class="code" href="distance__monitor_8cpp.html#a9df5b194e91cee8f60bf66de6c31cc23">turtle1PoseCallback</a>);</div>
<div class="line">ros::Subscriber sub_turtle2 = nh.subscribe(<span class="stringliteral">&quot;/turtle2/pose&quot;</span>, 10, <a class="code" href="distance__monitor_8cpp.html#af8f5c80ded86165f9faaf2a529b12d01">turtle2PoseCallback</a>);</div>
</div><!-- fragment --><p><b>turtle1PoseCallback</b> and <b>turtle2PoseCallback</b> are callback functions that update the global position variables (turtle1_x, turtle1_y, turtle2_x, turtle2_y) whenever new <b>Pose</b> messages are received from each turtle.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="distance__monitor_8cpp.html#a9df5b194e91cee8f60bf66de6c31cc23">turtle1PoseCallback</a>(<span class="keyword">const</span> turtlesim::Pose::ConstPtr&amp; msg) {</div>
<div class="line">  <a class="code" href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a> = msg-&gt;x;</div>
<div class="line">  <a class="code" href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a> = msg-&gt;y;</div>
<div class="line">  ROS_INFO(<span class="stringliteral">&quot;Turtle1 updated position: (%.2f, %.2f)&quot;</span>, <a class="code" href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a>, <a class="code" href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md40"></a>
3. Check if the turtle are too close to each other</h2>
<p>After calculating the distance, we use the <b>distance_threshold</b> to check if the turtles are too close. If the distance is less than the threshold, a flag is set to indicate that the turtles need attention. The following check updates the flag: </p><div class="fragment"><div class="line"><span class="comment">// Check if turtles are too close</span></div>
<div class="line"><span class="keywordtype">bool</span> is_too_close = (distance &lt;= <a class="code" href="distance__monitor_8cpp.html#aa1ac8686414dbfefaeac118fff7d3ebb">distance_threshold</a>);</div>
</div><!-- fragment --><p>This flag can then be used to trigger any necessary actions.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
4. Check if the turtle are near boundary</h2>
<p>To monitor if the turtles are approaching the boundary, we use a boolean flag. This flag is set by checking whether either of the turtles' coordinates are nearing or exceeding the predefined boundary limits. We perform this check using the <code><a class="el" href="distance__monitor_8cpp.html#ab8d39a2213dbc3a99c17f0f488f9d547" title="Check if a turtle is near the boundary.">is_near_boundary()</a></code> function, which compares both the x and y positions of the turtles against the boundary limits (<code>boundary_limit</code> and <code>max_limit</code>). If any coordinate is outside the allowed range, the function returns <code>true</code>, indicating that the turtle is near the boundary. </p><div class="fragment"><div class="line"><span class="comment">// Check if turtles are near boundaries</span></div>
<div class="line"><span class="keywordtype">bool</span> turtle1_near_boundary = <a class="code" href="distance__monitor_8cpp.html#ab8d39a2213dbc3a99c17f0f488f9d547">is_near_boundary</a>(<a class="code" href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a>, <a class="code" href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a>);</div>
<div class="line"><span class="keywordtype">bool</span> turtle2_near_boundary = <a class="code" href="distance__monitor_8cpp.html#ab8d39a2213dbc3a99c17f0f488f9d547">is_near_boundary</a>(<a class="code" href="distance__monitor_8cpp.html#a18b4c1bf1df6ad90f1e236bd496387f4">turtle2_x</a>, <a class="code" href="distance__monitor_8cpp.html#aa22dc3f61e7b2c48e0761801e1f124bf">turtle2_y</a>);</div>
</div><!-- fragment --><p>The <code>is_near_boundary</code> function is defined as: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="distance__monitor_8cpp.html#ab8d39a2213dbc3a99c17f0f488f9d547">is_near_boundary</a>(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (x &lt;= boundary_limit || x &gt;= <a class="code" href="distance__monitor_8cpp.html#a878bf73af4e66301337cd71ff79f622c">max_limit</a> || y &lt;= boundary_limit || y &gt;= <a class="code" href="distance__monitor_8cpp.html#a878bf73af4e66301337cd71ff79f622c">max_limit</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>If any of the flags (distance or boundary) are triggered, necessary actions are performed.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
5. Perform necessary action</h2>
<p>If the turtles are too close to each other or near the boundary, they need to be stopped. This is done by publishing zero velocity commands to each turtle. </p><div class="fragment"><div class="line"><span class="comment">// If turtles are too close or near boundary, stop them</span></div>
<div class="line"><span class="keywordflow">if</span> (is_too_close || turtle1_near_boundary || turtle2_near_boundary)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (is_too_close){</div>
<div class="line">      <a class="code" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a>(<a class="code" href="distance__monitor_8cpp.html#aca10e25faa94589e8f7dc10845abd1a0">pub_turtle1</a>);  <span class="comment">// Stop turtle1</span></div>
<div class="line">      <a class="code" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a>(<a class="code" href="distance__monitor_8cpp.html#a2beb12dd3123424a31990aebcd23133c">pub_turtle2</a>);  <span class="comment">// Stop turtle2</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (turtle1_near_boundary){</div>
<div class="line">      <a class="code" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a>(<a class="code" href="distance__monitor_8cpp.html#aca10e25faa94589e8f7dc10845abd1a0">pub_turtle1</a>);  <span class="comment">// Stop turtle1</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (turtle2_near_boundary){</div>
<div class="line">      <a class="code" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a>(<a class="code" href="distance__monitor_8cpp.html#a2beb12dd3123424a31990aebcd23133c">pub_turtle2</a>);  <span class="comment">// Stop turtle2</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code><a class="el" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21" title="Stop a turtle by publishing zero velocity.">stopTurtle()</a></code> function stops a turtle by publishing a <code>geometry_msgs::Twist</code> message with zero velocity: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a>(ros::Publisher &amp;pub){</div>
<div class="line">    geometry_msgs::Twist stop_msg;</div>
<div class="line">    stop_msg.linear.x = 0.0;</div>
<div class="line">    stop_msg.angular.z = 0.0;</div>
<div class="line">    pub.publish(stop_msg);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This ensures that turtles stop moving when they're too close or near the boundaries.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
6. Check and handle the overshoot issue</h2>
<ul>
<li><b>Issue</b><br  />
 The overshoot occurs because the turtle does not stop exactly at the boundary due to delays in processing movement commands, such as timing or message delays. As the turtle approaches the boundary, the system may not react quickly enough, causing it to move past the boundary. Additionally, when reversing from the boundary, the system might incorrectly detect the turtle as too close, causing it to stop prematurely and prompt the user to input velocity conditions again. This behavior is undesirable and needs to be avoided. The issue is further exacerbated when the turtle's velocity is too fast, as the system has less time to process the stop command and adjust the turtle's position before it crosses the boundary.</li>
<li><b>Solutions</b><br  />
</li>
</ul>
<ol type="1">
<li>Limit Turtle's Velocity<br  />
 A velocity constraint of between <b>5</b> and <b>-5</b> has been enforced. This ensures that the turtle moves at a manageable speed, allowing the system sufficient time to process movement commands and react to boundary conditions effectively. The loop rate for processing messages is set to 10 Hz, meaning the system processes 10 messages per second. By restricting velocity to this range, the turtle's position updates occur smoothly, preventing excessive overshoot due to high-speed movement.<br  />
 Look at <a href="#error-handling-issue">error explaination</a> section above for explanation of the code.<br  />
 Even with velocity constraints, minor overshoot may still occur because of message delays or edge cases. For such scenarios, an auto-adjustment mechanism is suggested to be added to bring the turtle back within boundaries when overshoot is detected.</li>
<li><p class="startli">Auto-adjust Position Near Boundary<br  />
 After the turtle stops, we need to check if it has overshot the boundary. If the turtle has moved past the defined boundaries, we reposition it back within the allowed area. This is achieved by checking the turtle’s position and applying corrective velocities.</p><ul>
<li>Check for Overshoot:</li>
</ul>
<p class="startli">We use a boolean flag to check whether the turtle's position exceeds the defined boundary. This is done using the <code>check_if_overshot_boundary</code> function, which checks if the current position is outside the allowable range. If the turtle’s position exceeds the boundary, we flag it as an overshoot. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> turtle1_overshot = <a class="code" href="distance__monitor_8cpp.html#a13286d6716af370899e73f9fd7634d63">check_if_overshot_boundary</a>(<a class="code" href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a>, <a class="code" href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a>);</div>
<div class="line"><span class="keywordtype">bool</span> turtle2_overshot = <a class="code" href="distance__monitor_8cpp.html#a13286d6716af370899e73f9fd7634d63">check_if_overshot_boundary</a>(<a class="code" href="distance__monitor_8cpp.html#a18b4c1bf1df6ad90f1e236bd496387f4">turtle2_x</a>, <a class="code" href="distance__monitor_8cpp.html#aa22dc3f61e7b2c48e0761801e1f124bf">turtle2_y</a>);</div>
<div class="line"><span class="keywordtype">bool</span> <a class="code" href="distance__monitor_8cpp.html#a13286d6716af370899e73f9fd7634d63">check_if_overshot_boundary</a>(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y){</div>
<div class="line">  <span class="keywordflow">if</span> (x &gt; <a class="code" href="distance__monitor_8cpp.html#a878bf73af4e66301337cd71ff79f622c">max_limit</a> || x &lt; boundary_limit  || y &gt; <a class="code" href="distance__monitor_8cpp.html#a878bf73af4e66301337cd71ff79f622c">max_limit</a> || y &lt; <a class="code" href="distance__monitor_8cpp.html#a8fae504c5b5982cecffc3c82190a1f29">boundary_limit</a> ){</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">} </div>
</div><!-- fragment --><ul>
<li>Handle Overshoot:</li>
</ul>
<p class="startli">Once the overshoot is detected, we adjust the turtle’s position by applying corrective velocities to bring it back inside the defined boundary.</p>
</li>
</ol>
<p><em><b>Note:</b></em></p><ul>
<li>I have decided to remove the implementation that attempts to correct the overshoot issue. While the logic was working as intended, it introduced other complications during testing. Rather than submitting something unreliable, I have chosen to provide a more stable solution that ensures functional behavior. The current implementation checks for overshoot occurrences and notifies the user with a warning when an overshoot is detected. <div class="fragment"><div class="line"><span class="keywordflow">if</span> (turtle1_overshot){</div>
<div class="line">    ROS_WARN(<span class="stringliteral">&quot;Turtle1 is over the boundary after stopping!&quot;</span>);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (turtle2_overshot){</div>
<div class="line">    ROS_WARN(<span class="stringliteral">&quot;Turtle2 is over the boundary after stopping!&quot;</span>); </div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>The <b>C++</b> <code>distance monitor</code> node had some wonky logic to handle overshoot near simulation boundaries. It mostly worked but introduced a few complications, which is why I decided to remove it.This logic has been commented out to keep things simpler, but it is still in the source for reference.</li>
<li>Additionally, the overshoot issue can also arise when the turtles get too close to each other. Similar to overshoot near boundaries, here, I have only implemented a check to alert the user when the turtles are way too close in proximity (i.e., below a predefined distance threshold). Further action to address these behaviors can be programmed at a later stage. <div class="fragment"><div class="line"><span class="keywordflow">if</span> (is_too_close)</div>
<div class="line">  {</div>
<div class="line">      <a class="code" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a>(<a class="code" href="distance__monitor_8cpp.html#aca10e25faa94589e8f7dc10845abd1a0">pub_turtle1</a>);  <span class="comment">// Stop turtle1</span></div>
<div class="line">      <a class="code" href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a>(<a class="code" href="distance__monitor_8cpp.html#a2beb12dd3123424a31990aebcd23133c">pub_turtle2</a>);  <span class="comment">// Stop turtle2</span></div>
<div class="line">      <span class="keywordtype">float</span> distance = sqrt(pow(<a class="code" href="distance__monitor_8cpp.html#a18b4c1bf1df6ad90f1e236bd496387f4">turtle2_x</a> - <a class="code" href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a>, 2) + pow(<a class="code" href="distance__monitor_8cpp.html#aa22dc3f61e7b2c48e0761801e1f124bf">turtle2_y</a> - <a class="code" href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a>, 2));</div>
<div class="line">      <span class="keywordflow">if</span> (distance &lt; <a class="code" href="distance__monitor_8cpp.html#aa1ac8686414dbfefaeac118fff7d3ebb">distance_threshold</a>){</div>
<div class="line">          ROS_WARN(<span class="stringliteral">&quot;Turtles are really too close !!!&quot;</span>);</div>
<div class="line">      }}</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md44"></a>
Summary</h1>
<p>The current implementation successfully meets the main objectives of the assignment with a well-structured approach.</p>
<p>The <code>user interface</code> node performs key tasks smoothly: spawning <code>turtle2</code>, allowing users to select which turtle to control, and setting both angular and linear velocities. It also checks and handles invalid user input, ensuring the system remains robust and reliable. The node moves the turtles for one second based on the input, stops them, and then prompts the user for further commands.</p>
<p>Similarly, the <code>distance monitor</code> node efficiently handles the required tasks. It ensures turtles stop at designated boundaries and prevents collisions by halting them at a defined distance threshold. Although handling of overshoot and boundary issues has been removed for now, the program still includes basic checks for overshoot, notifying the user when it occurs or when the turtles are too close to one another.</p>
<p>Overall, the solution is stable and reliable in its current form, but there is potential for future improvements and optimizations. Areas for enhancement include refining the distance monitoring system, improving overshoot handling, and integrating more advanced features to offer better control and flexibility in managing turtle interactions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="adistance__monitor_8cpp_html_af8f5c80ded86165f9faaf2a529b12d01"><div class="ttname"><a href="distance__monitor_8cpp.html#af8f5c80ded86165f9faaf2a529b12d01">turtle2PoseCallback</a></div><div class="ttdeci">void turtle2PoseCallback(const turtlesim::Pose::ConstPtr &amp;msg)</div><div class="ttdoc">Callback function for turtle2's pose.</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:150</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_aa1ac8686414dbfefaeac118fff7d3ebb"><div class="ttname"><a href="distance__monitor_8cpp.html#aa1ac8686414dbfefaeac118fff7d3ebb">distance_threshold</a></div><div class="ttdeci">const float distance_threshold</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:31</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a878bf73af4e66301337cd71ff79f622c"><div class="ttname"><a href="distance__monitor_8cpp.html#a878bf73af4e66301337cd71ff79f622c">max_limit</a></div><div class="ttdeci">const float max_limit</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:33</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a2b590ca78ab10ef0c89adb2da9a86e21"><div class="ttname"><a href="distance__monitor_8cpp.html#a2b590ca78ab10ef0c89adb2da9a86e21">stopTurtle</a></div><div class="ttdeci">void stopTurtle(ros::Publisher &amp;pub)</div><div class="ttdoc">Stop a turtle by publishing zero velocity.</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:182</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a9df5b194e91cee8f60bf66de6c31cc23"><div class="ttname"><a href="distance__monitor_8cpp.html#a9df5b194e91cee8f60bf66de6c31cc23">turtle1PoseCallback</a></div><div class="ttdeci">void turtle1PoseCallback(const turtlesim::Pose::ConstPtr &amp;msg)</div><div class="ttdoc">Callback function for turtle1's pose.</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:141</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a386ca21344ebf1087871f54d8e89f93a"><div class="ttname"><a href="distance__monitor_8cpp.html#a386ca21344ebf1087871f54d8e89f93a">turtle1_x</a></div><div class="ttdeci">float turtle1_x</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:30</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_aa22dc3f61e7b2c48e0761801e1f124bf"><div class="ttname"><a href="distance__monitor_8cpp.html#aa22dc3f61e7b2c48e0761801e1f124bf">turtle2_y</a></div><div class="ttdeci">float turtle2_y</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:30</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a8fae504c5b5982cecffc3c82190a1f29"><div class="ttname"><a href="distance__monitor_8cpp.html#a8fae504c5b5982cecffc3c82190a1f29">boundary_limit</a></div><div class="ttdeci">const float boundary_limit</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:32</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a18b4c1bf1df6ad90f1e236bd496387f4"><div class="ttname"><a href="distance__monitor_8cpp.html#a18b4c1bf1df6ad90f1e236bd496387f4">turtle2_x</a></div><div class="ttdeci">float turtle2_x</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:30</div></div>
<div class="ttc" id="auser__interface_8cpp_html_afa644bf33e0fb93ec0f706746816bbcd"><div class="ttname"><a href="user__interface_8cpp.html#afa644bf33e0fb93ec0f706746816bbcd">angular_z</a></div><div class="ttdeci">float angular_z</div><div class="ttdef"><b>Definition:</b> user_interface.cpp:30</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_aca10e25faa94589e8f7dc10845abd1a0"><div class="ttname"><a href="distance__monitor_8cpp.html#aca10e25faa94589e8f7dc10845abd1a0">pub_turtle1</a></div><div class="ttdeci">ros::Publisher pub_turtle1</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:43</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a2beb12dd3123424a31990aebcd23133c"><div class="ttname"><a href="distance__monitor_8cpp.html#a2beb12dd3123424a31990aebcd23133c">pub_turtle2</a></div><div class="ttdeci">ros::Publisher pub_turtle2</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:43</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_af699f1ae0d9eb8f524d8820a806f1a1a"><div class="ttname"><a href="distance__monitor_8cpp.html#af699f1ae0d9eb8f524d8820a806f1a1a">turtle1_y</a></div><div class="ttdeci">float turtle1_y</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:30</div></div>
<div class="ttc" id="auser__interface_8cpp_html_a6ef24e69b57370abcf35b40ec777f18f"><div class="ttname"><a href="user__interface_8cpp.html#a6ef24e69b57370abcf35b40ec777f18f">linear_x</a></div><div class="ttdeci">float linear_x</div><div class="ttdef"><b>Definition:</b> user_interface.cpp:30</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_ab8d39a2213dbc3a99c17f0f488f9d547"><div class="ttname"><a href="distance__monitor_8cpp.html#ab8d39a2213dbc3a99c17f0f488f9d547">is_near_boundary</a></div><div class="ttdeci">bool is_near_boundary(float x, float y)</div><div class="ttdoc">Check if a turtle is near the boundary.</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:161</div></div>
<div class="ttc" id="adistance__monitor_8cpp_html_a13286d6716af370899e73f9fd7634d63"><div class="ttname"><a href="distance__monitor_8cpp.html#a13286d6716af370899e73f9fd7634d63">check_if_overshot_boundary</a></div><div class="ttdeci">bool check_if_overshot_boundary(float x, float y)</div><div class="ttdoc">Check if a turtle has overshot the boundary after stopping.</div><div class="ttdef"><b>Definition:</b> distance_monitor.cpp:171</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
