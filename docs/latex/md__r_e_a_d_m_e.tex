This repository contains the assignment work for the {\bfseries{Research Track}} course, completed by\+: ~\newline
 {\bfseries{Rubin Khadka Chhetri}} ~\newline
 {\bfseries{ID\+: 6558048}}\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Table of Contents}\label{md__r_e_a_d_m_e_autotoc_md1}

\begin{DoxyItemize}
\item \href{\#introduction}{\texttt{ Introduction}}
\item \href{\#node-details}{\texttt{ Node Details}}
\begin{DoxyItemize}
\item \href{\#1-user-interface-node-user_interface}{\texttt{ User Interface Node}}
\item \href{\#2-distance-monitor-node-distance_monitor}{\texttt{ Distance Monitor Node}}
\end{DoxyItemize}
\item \href{\#repository-structure}{\texttt{ Repository Structure}}
\item \href{\#getting-started-read-before-action}{\texttt{ Getting Started (Read Before Action)}}
\begin{DoxyItemize}
\item \href{\#prerequisites}{\texttt{ Prerequisites}}
\item \href{\#setup}{\texttt{ Setup}}
\end{DoxyItemize}
\item \href{\#launching-simulation-and-nodes}{\texttt{ Launching Simulation and Nodes}}
\begin{DoxyItemize}
\item \href{\#running-the-c-version}{\texttt{ Running C++ version}}
\item \href{\#running-the-python-version}{\texttt{ Running Python version}}
\item \href{\#alternative-configurations}{\texttt{ Alternative Configurations}}
\end{DoxyItemize}
\item \href{\#implementation-details}{\texttt{ Implementation Details}}
\begin{DoxyItemize}
\item \href{\#user-interface-node}{\texttt{ User Interface Node}}
\item \href{\#distance-monitor-node}{\texttt{ Distance Monitor Node}}
\end{DoxyItemize}
\item \href{\#summary}{\texttt{ Summary}}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{Introduction}\label{md__r_e_a_d_m_e_autotoc_md2}
This repository implements a R\+OS package containing two main nodes\+:


\begin{DoxyItemize}
\item {\bfseries{User Interface node}}
\item {\bfseries{Distance Monitor node}}
\end{DoxyItemize}

These nodes work together within the $\ast$$\ast${\ttfamily turtlesim}$\ast$$\ast$ simulation environment to create a simple, interactive system for controlling and monitoring two turtles.

{\itshape {\bfseries{Note\+:}}}\+:
\begin{DoxyItemize}
\item This assignment is completed using both {\bfseries{Python}} and {\bfseries{C++}}.
\item Custom message is included in this project, which is not required. The turtles distance is published in the {\ttfamily turtle\+\_\+distance\+\_\+topic} using this custom message. It good for further development.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{Node Details}\label{md__r_e_a_d_m_e_autotoc_md3}
\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysubsection{1. User Interface Node (user\+\_\+interface)}\label{md__r_e_a_d_m_e_autotoc_md4}
This node is responsible for handling user input and controlling the movements of two turtles ({\ttfamily turtle1} and {\ttfamily turtle2}) in the simulator. Its key functions include\+:
\begin{DoxyItemize}
\item Spawns a second turtle ({\ttfamily turtle2}) in the simulation environment.
\item Prompts the user to\+:
\begin{DoxyItemize}
\item Select which turtle to control (either {\ttfamily turtle1} or {\ttfamily turtle2}).
\item Set the selected turtle\textquotesingle{}s linear and angular velocities.
\end{DoxyItemize}
\item Sends movement commands to the selected turtle, causing it to move for one second. After the movement, the turtle stops, and the interface is ready to accept the next command.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysubsection{2. Distance Monitor Node (distance\+\_\+monitor)}\label{md__r_e_a_d_m_e_autotoc_md5}
This node ensures that the turtles maintain safe distances from each other and stay within the boundaries of the simulation environment. This node continuously calculates and monitors turtle positions. Its key features are\+:
\begin{DoxyItemize}
\item Continuously calculates the distance between {\ttfamily turtle1} and {\ttfamily turtle2} and publishes this information on a dedicated R\+OS topic for monitoring.
\item Automatically stops a turtle if it approaches the other turtle.
\item Stops a turtle if it\textquotesingle{}s position is too close to the boundaries.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md6}{}\doxysection{Repository Structure}\label{md__r_e_a_d_m_e_autotoc_md6}
The root of this repository is the package folder, which contains all necessary files and scripts for running the assignment nodes. When cloning the repository for the first time, place it directly in the {\ttfamily src} folder of your R\+OS workspace.\hypertarget{md__r_e_a_d_m_e_autotoc_md7}{}\doxysubsection{Folder and File Overview}\label{md__r_e_a_d_m_e_autotoc_md7}

\begin{DoxyItemize}
\item $\ast$$\ast${\ttfamily /msg}$\ast$$\ast$\+: Contains custom message definitions.
\begin{DoxyItemize}
\item {\ttfamily turtle\+\_\+distance.\+msg}\+: Custom message file for distance monitoring and boundary status. Contains {\ttfamily float32 distance} msg which is required to publish distance to {\ttfamily turtle\+\_\+distance\+\_\+topic}.
\end{DoxyItemize}
\item $\ast$$\ast${\ttfamily /scripts}$\ast$$\ast$\+: Contains Python scripts used for the nodes in this project.
\begin{DoxyItemize}
\item {\ttfamily \mbox{\hyperlink{user__interface_8py}{user\+\_\+interface.\+py}}}\+: Python version of user interface node.
\item {\ttfamily \mbox{\hyperlink{distance__monitor_8py}{distance\+\_\+monitor.\+py}}}\+: Python version of distance monitor node.
\end{DoxyItemize}
\item $\ast$$\ast${\ttfamily /src}$\ast$$\ast$\+: Contains C++ source files.
\begin{DoxyItemize}
\item {\ttfamily \mbox{\hyperlink{user__interface_8cpp}{user\+\_\+interface.\+cpp}}}\+: C++ version of the user interface node.
\item {\ttfamily \mbox{\hyperlink{distance__monitor_8cpp}{distance\+\_\+monitor.\+cpp}}}\+: C++ version of the distance monitor node.
\end{DoxyItemize}
\item $\ast$$\ast${\ttfamily /\+C\+Make\+Lists.txt}$\ast$$\ast$\+: Specifies the package build rules.
\item $\ast$$\ast${\ttfamily /package.xml}$\ast$$\ast$\+: Lists dependencies and package metadata.
\item $\ast$$\ast${\ttfamily /\+R\+E\+A\+D\+ME.md}$\ast$$\ast$\+: This file (Documentation).
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md8}{}\doxysection{Getting Started (\+Read Before Action)}\label{md__r_e_a_d_m_e_autotoc_md8}
\hypertarget{md__r_e_a_d_m_e_autotoc_md9}{}\doxysubsection{Prerequisites}\label{md__r_e_a_d_m_e_autotoc_md9}
Before proceeding, make sure that $\ast$$\ast${\ttfamily R\+OS Noetic}$\ast$$\ast$ is installed on your system.~\newline
 If you haven’t set up R\+OS yet, check this official guide to install R\+OS\+: ~\newline
 (\href{https://wiki.ros.org/noetic/Installation/Ubuntu}{\texttt{ https\+://wiki.\+ros.\+org/noetic/\+Installation/\+Ubuntu}}) ~\newline


Additionally, you’ll need $\ast$$\ast${\ttfamily Python 3}$\ast$$\ast$ and $\ast$$\ast${\ttfamily turtlesim}$\ast$$\ast$ package to run this project. Ensure they are installed on your system. If not, you can install them by running\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo apt-\/get update}
\DoxyCodeLine{sudo apt-\/get install ros-\/noetic-\/turtlesim}
\DoxyCodeLine{sudo apt-\/get install python3}
\end{DoxyCode}


After installation, you can proceed to cloning the repository.\hypertarget{md__r_e_a_d_m_e_autotoc_md10}{}\doxysubsection{Setup}\label{md__r_e_a_d_m_e_autotoc_md10}
\hypertarget{md__r_e_a_d_m_e_autotoc_md11}{}\doxysubsubsection{1. Set up your R\+O\+S workspace}\label{md__r_e_a_d_m_e_autotoc_md11}
Create a new workspace (or use an existing one) and navigate to its {\ttfamily src} directory\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{mkdir -\/p \string~/my\_new\_ws/src}
\DoxyCodeLine{cd \string~/my\_new\_ws/src}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md12}{}\doxysubsubsection{2. Clone this repository}\label{md__r_e_a_d_m_e_autotoc_md12}
Clone the assignment repository into your workspace’s {\ttfamily src} folder\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{git clone https://github.com/Rubin-\/unige/assignment1\_rt.git}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md13}{}\doxysubsubsection{3. Add the Workspace to Your R\+O\+S Environment}\label{md__r_e_a_d_m_e_autotoc_md13}
To ensure that your workspace is sourced automatically every time you start a new terminal session, add it to your {\ttfamily .bashrc} file\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{echo "source \string~/my\_new\_ws/devel/setup.bash" >> \string~/.bashrc}
\DoxyCodeLine{source \string~/.bashrc}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md14}{}\doxysubsubsection{4. Build the Package}\label{md__r_e_a_d_m_e_autotoc_md14}
Navigate to the root of your workspace and build the package using {\ttfamily catkin\+\_\+make}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cd \string~/my\_new\_ws}
\DoxyCodeLine{catkin\_make}
\end{DoxyCode}


After building, your workspace will be ready to launch the nodes in the package.\hypertarget{md__r_e_a_d_m_e_autotoc_md15}{}\doxysection{Launching Simulation and Nodes}\label{md__r_e_a_d_m_e_autotoc_md15}
\hypertarget{md__r_e_a_d_m_e_autotoc_md16}{}\doxysubsubsection{1. Start the R\+O\+S Master}\label{md__r_e_a_d_m_e_autotoc_md16}
Before running any R\+OS nodes, make sure the R\+OS Master is up and running. Open a terminal and start {\ttfamily roscore}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{roscore}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md17}{}\doxysubsubsection{2. Run the Turtlesim Node}\label{md__r_e_a_d_m_e_autotoc_md17}
Next, start the {\ttfamily Turtlesim} node in a new terminal to launch the simulation environment\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rosrun turtlesim turtlesim\_node}
\end{DoxyCode}


This will open the Turtlesim window where the turtles ({\ttfamily turtle1} and {\ttfamily turtle2}) will appear.\hypertarget{md__r_e_a_d_m_e_autotoc_md18}{}\doxysubsubsection{3. Run the User Interface and Distance Monitor Nodes}\label{md__r_e_a_d_m_e_autotoc_md18}
At this point, you can proceed to run either the {\bfseries{C++}} or {\bfseries{Python}} version of the {\ttfamily User Interface} and {\ttfamily Distance Monitor} nodes, depending on which implementation you want to use. The nodes can be run individually or in combination, offering flexibility in how you choose to execute them.\hypertarget{md__r_e_a_d_m_e_autotoc_md19}{}\doxysection{\#\#\#\# Running the C++ Version}\label{md__r_e_a_d_m_e_autotoc_md19}
To run the C++ nodes, follow these steps\+:
\begin{DoxyItemize}
\item Make sure that the {\ttfamily roscore} and {\ttfamily turtlesim} nodes are running.
\item In a new terminal, run the {\bfseries{C++ User Interface Node}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rosrun assignment1\_rt user\_interface}
\end{DoxyCode}

\item In another terminal, run the {\bfseries{C++ Distance Monitor Node}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rosrun assignment1\_rt distance\_monitor}
\end{DoxyCode}

\end{DoxyItemize}

This will start both the {\bfseries{C++ user interface}} for controlling the turtles and the {\bfseries{distance monitor}} to track their movements.\hypertarget{md__r_e_a_d_m_e_autotoc_md20}{}\doxysection{\#\#\#\# Running the Python Version}\label{md__r_e_a_d_m_e_autotoc_md20}
To run the Python nodes, follow these steps\+:
\begin{DoxyItemize}
\item Make sure that the {\ttfamily roscore} and {\ttfamily turtlesim} nodes are running.
\item Make the {\bfseries{Python scripts executable}}
\end{DoxyItemize}

Before running the Python scripts, you need to ensure they are executable. Run the following command for each Python script ({\ttfamily \mbox{\hyperlink{user__interface_8py}{user\+\_\+interface.\+py}}} and {\ttfamily \mbox{\hyperlink{distance__monitor_8py}{distance\+\_\+monitor.\+py}}})\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{chmod +x \string~/my\_new\_ws/src/assignment1\_rt/scripts/user\_interface.py}
\DoxyCodeLine{chmod +x \string~/my\_new\_ws/src/assignment1\_rt/scripts/distance\_monitor.py}
\end{DoxyCode}



\begin{DoxyItemize}
\item After making the scripts executable, run the {\bfseries{Python User Interface Node}} in the same terminal\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rosrun assignment1\_rt user\_interface.py}
\end{DoxyCode}

\item Open a new terminal and run the {\bfseries{Python Distance Monitor Node}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rosrun assignment1\_rt distance\_monitor.py}
\end{DoxyCode}

\end{DoxyItemize}

This will start both the {\bfseries{Python user interface}} for controlling the turtles and the {\bfseries{distance monitor}} to track their movements.\hypertarget{md__r_e_a_d_m_e_autotoc_md21}{}\doxysection{\#\#\#\# Alternative Configurations}\label{md__r_e_a_d_m_e_autotoc_md21}
The program is flexible, allowing you to mix and match the {\bfseries{C++}} and {\bfseries{Python}} nodes based on your preference. For example, you can run the {\ttfamily C++ User Interface} node while running the {\ttfamily Python Distance Monitor} node, or vice versa. This allows you to run the system in the configuration that best suits your workflow and testing needs.\hypertarget{md__r_e_a_d_m_e_autotoc_md22}{}\doxysubsubsection{4. Stopping the nodes}\label{md__r_e_a_d_m_e_autotoc_md22}
To stop the nodes, simply press {\ttfamily Ctrl+C} in the terminal where each node is running ({\ttfamily User Interface}, {\ttfamily Distance Monitor}, {\ttfamily Turtlesim}, or {\ttfamily roscore}). This will terminate the nodes and stop the simulation.\hypertarget{md__r_e_a_d_m_e_autotoc_md23}{}\doxysection{Implementation Details}\label{md__r_e_a_d_m_e_autotoc_md23}
\hypertarget{md__r_e_a_d_m_e_autotoc_md24}{}\doxysubsection{User Interface Node}\label{md__r_e_a_d_m_e_autotoc_md24}
The structure of the {\ttfamily \mbox{\hyperlink{namespaceuser__interface}{user\+\_\+interface}}} node is similar in both {\bfseries{C++}} and {\bfseries{Python}}. The logic for handling user inputs, setting velocities, and publishing commands is nearly identical in both languages. Since the logic for both versions is fundamentally the same, I will explain the details using the {\bfseries{C++}} version as an example.

However, there was one key difference when running the node in {\bfseries{Python}}\+: if the user closed the node and opened it again, {\ttfamily turtle2} would already exist in the simulation, causing a conflict. This issue did not occur in the {\bfseries{C++}} implementation, where if {\ttfamily turtle2} already existed, the node would simply display a message saying \char`\"{}turtle2 already exists\char`\"{} and take the position from the already existing turtle.

In the {\bfseries{Python}} version, when the node is restarted, attempting to spawn {\ttfamily turtle2} again would cause the node to crash because {\ttfamily turtle2} already existed in the simulation. To address this, additional checks were implemented to ensure that {\ttfamily turtle2} is only spawned if it doesn\textquotesingle{}t already exist. This solution is explained below in separate section.\hypertarget{md__r_e_a_d_m_e_autotoc_md25}{}\doxysubsection{1. Spawning Turtle2}\label{md__r_e_a_d_m_e_autotoc_md25}
The {\ttfamily \mbox{\hyperlink{namespaceuser__interface}{user\+\_\+interface}}} node automatically spawns a second turtle, {\ttfamily turtle2}, in the simulation when the program starts. This is accomplished using the {\ttfamily /spawn} service provided by {\ttfamily turtlesim}, which allows for creating a new turtle at a specified position and orientation in the simulation environment.

In this implementation\+:


\begin{DoxyItemize}
\item {\ttfamily turtle2} is spawned at coordinates $\ast$$\ast$(5.\+0, 2.\+0)$\ast$$\ast$ with an orientation of {\bfseries{0.\+0}} radians, positioning it to face directly to the right.
\item The {\ttfamily /spawn} service is called during the initialization phase of the node, ensuring that {\ttfamily turtle2} is added automatically without requiring any user input.
\end{DoxyItemize}

Below is the code that sets up the spawn request\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Initialise service clients}}
\DoxyCodeLine{ros::ServiceClient client\_spawn = nh.serviceClient <turtlesim::Spawn> (\textcolor{stringliteral}{"/spawn"});}
\DoxyCodeLine{turtlesim::Spawn spawn\_srv;}
\DoxyCodeLine{\textcolor{comment}{// Spawn Turtle}}
\DoxyCodeLine{spawn\_srv.request.x = 5.0;}
\DoxyCodeLine{spawn\_srv.request.y = 2.0;}
\DoxyCodeLine{spawn\_srv.request.theta = 0.0;}
\DoxyCodeLine{spawn\_srv.request.name = \textcolor{stringliteral}{"turtle2"};}
\DoxyCodeLine{client\_spawn.call(spawn\_srv);}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md26}{}\doxysubsection{2. User Interface}\label{md__r_e_a_d_m_e_autotoc_md26}
The user interface of the {\ttfamily \mbox{\hyperlink{namespaceuser__interface}{user\+\_\+interface}}} node allows the user to control either {\ttfamily turtle1} or {\ttfamily turtle2} by setting their velocities.\hypertarget{md__r_e_a_d_m_e_autotoc_md27}{}\doxysubsubsection{1. Selecting the Turtle}\label{md__r_e_a_d_m_e_autotoc_md27}
The user is prompted to select a turtle (either {\ttfamily turtle1} or {\ttfamily turtle2}). If an invalid input is provided, the program will re-\/prompt the user until a valid turtle name is entered


\begin{DoxyCode}{0}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Enter the turtle you want to control (turtle1 or turtle2): "};}
\DoxyCodeLine{std::cin >> turtle\_name;}
\DoxyCodeLine{\textcolor{keywordflow}{if} (turtle\_name != \textcolor{stringliteral}{"turtle1"} \&\& turtle\_name != \textcolor{stringliteral}{"turtle2"}) \{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"Invalid turtle name. Please enter 'turtle1' or 'turtle2'.\(\backslash\)n"};}
\DoxyCodeLine{  \textcolor{keywordflow}{continue};}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md28}{}\doxysubsubsection{2. Setting Velocities}\label{md__r_e_a_d_m_e_autotoc_md28}
After selecting a turtle, the user is asked to enter the linear and angular velocities. Error handling ensures only valid numeric inputs are accepted.


\begin{DoxyItemize}
\item Linear Velocity (x)\+:~\newline
 The user is prompted for the linear velocity. If the input is invalid, the program clears the error state and asks the user to re-\/enter a valid value. 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Enter the linear velocity x (between -\/5 and 5): "};}
\DoxyCodeLine{\textcolor{keywordflow}{while} (!(std::cin >> \mbox{\hyperlink{user__interface_8cpp_a6ef24e69b57370abcf35b40ec777f18f}{linear\_x}}) || linear\_x < -\/5 || linear\_x > 5) \{ }
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Invalid input. Please enter a linear velocity between -\/5 and 5: "};}
\DoxyCodeLine{    std::cin.clear(); \textcolor{comment}{// Clear error}}
\DoxyCodeLine{    std::cin.ignore(std::numeric\_limits<std::streamsize>::max(), \textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{\}}
\end{DoxyCode}

\item Angular Velocity (z)\+:~\newline
 The same process is repeated for the angular velocity input. 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Enter the angular velocity z (between -\/5 and 5): "};}
\DoxyCodeLine{\textcolor{keywordflow}{while} (!(std::cin >> \mbox{\hyperlink{user__interface_8cpp_afa644bf33e0fb93ec0f706746816bbcd}{angular\_z}}) || angular\_z < -\/5 || angular\_z > 5) \{ }
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Invalid input. Please enter an angular velocity between -\/5 and 5: "};}
\DoxyCodeLine{    std::cin.clear(); \textcolor{comment}{// Clear error}}
\DoxyCodeLine{    std::cin.ignore(std::numeric\_limits<std::streamsize>::max(), \textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{\}}
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md29}{}\doxysubsubsection{Error Handling Issue}\label{md__r_e_a_d_m_e_autotoc_md29}

\begin{DoxyItemize}
\item {\bfseries{Invalid user input issue}}
\end{DoxyItemize}

During the initial implementation of the node, I faced an issue with invalid inputs for the velocities. If the user entered a non-\/numeric value, the program would crash or behave unexpectedly. To resolve this, I added error handling that clears the input buffer and prompts the user to re-\/enter valid values for both the linear and angular velocities.


\begin{DoxyItemize}
\item {\bfseries{Overshoot Issue}}
\end{DoxyItemize}

While running the distance monitor node, I encountered the overshoot issue, which is explained in more detail in the \href{\#6-check-and-handle-the-overshoot-issue}{\texttt{ Overshoot Issue}} section. One of the solutions to this problem was to constrain the velocities the user can input, thereby giving the program enough time to process the information. As shown in the code above, users are only allowed to enter velocities between {\bfseries{-\/5}} and {\bfseries{5}}, which helps to prevent the turtle from moving too quickly and overshooting the boundary.\hypertarget{md__r_e_a_d_m_e_autotoc_md30}{}\doxysubsection{3. Publishing User Input}\label{md__r_e_a_d_m_e_autotoc_md30}
Once the user has selected the turtle and entered the linear and angular velocities, the {\ttfamily \mbox{\hyperlink{namespaceuser__interface}{user\+\_\+interface}}} node publishes these commands to the respective turtle\textquotesingle{}s velocity topic.

The following steps are taken to publish the user inputs\+:\hypertarget{md__r_e_a_d_m_e_autotoc_md31}{}\doxysubsubsection{1. Turtle Selection}\label{md__r_e_a_d_m_e_autotoc_md31}
After the user selects the turtle, the node checks which turtle was selected and publishes the corresponding velocity commands to the respective topic.
\begin{DoxyItemize}
\item {\ttfamily turtle1} uses the topic {\ttfamily /turtle1/cmd\+\_\+vel}.
\item {\ttfamily turtle2} uses the topic {\ttfamily /turtle2/cmd\+\_\+vel}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{ros::Publisher \mbox{\hyperlink{distance__monitor_8cpp_aca10e25faa94589e8f7dc10845abd1a0}{pub\_turtle1}} = nh.advertise <geometry\_msgs::Twist>(\textcolor{stringliteral}{"/turtle1/cmd\_vel"}, 10);}
\DoxyCodeLine{ros::Publisher \mbox{\hyperlink{distance__monitor_8cpp_a2beb12dd3123424a31990aebcd23133c}{pub\_turtle2}} = nh.advertise <geometry\_msgs::Twist>(\textcolor{stringliteral}{"/turtle2/cmd\_vel"}, 10);}
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md32}{}\doxysubsubsection{2. Publishing the Velocity Command}\label{md__r_e_a_d_m_e_autotoc_md32}
A {\ttfamily geometry\+\_\+msgs\+::\+Twist} message is created, which holds the linear and angular velocities. This message is then published to the appropriate topic using the publisher.

Below is the code for publishing the velocities\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{geometry\_msgs::Twist turtle\_vel;}
\DoxyCodeLine{turtle\_vel.linear.x = \mbox{\hyperlink{user__interface_8cpp_a6ef24e69b57370abcf35b40ec777f18f}{linear\_x}};}
\DoxyCodeLine{turtle\_vel.angular.z = \mbox{\hyperlink{user__interface_8cpp_afa644bf33e0fb93ec0f706746816bbcd}{angular\_z}};}
\DoxyCodeLine{\textcolor{keywordflow}{if} (turtle\_name == \textcolor{stringliteral}{"turtle1"})}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \mbox{\hyperlink{distance__monitor_8cpp_aca10e25faa94589e8f7dc10845abd1a0}{pub\_turtle1}}.publish(turtle\_vel);}
\DoxyCodeLine{  ros::Duration(1.0).sleep();}
\DoxyCodeLine{  turtle\_vel.linear.x = 0.0;}
\DoxyCodeLine{  turtle\_vel.angular.z = 0.0;}
\DoxyCodeLine{  \mbox{\hyperlink{distance__monitor_8cpp_aca10e25faa94589e8f7dc10845abd1a0}{pub\_turtle1}}.publish(turtle\_vel);}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (turtle\_name == \textcolor{stringliteral}{"turtle2"}) \{}
\DoxyCodeLine{  \mbox{\hyperlink{distance__monitor_8cpp_a2beb12dd3123424a31990aebcd23133c}{pub\_turtle2}}.publish(turtle\_vel);  }
\DoxyCodeLine{  ros::Duration(1.0).sleep();    }
\DoxyCodeLine{  turtle\_vel.linear.x = 0;         }
\DoxyCodeLine{  turtle\_vel.angular.z = 0;}
\DoxyCodeLine{  \mbox{\hyperlink{distance__monitor_8cpp_a2beb12dd3123424a31990aebcd23133c}{pub\_turtle2}}.publish(turtle\_vel); }
\DoxyCodeLine{\} }
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md33}{}\doxysubsubsection{Explanation of the Code}\label{md__r_e_a_d_m_e_autotoc_md33}

\begin{DoxyItemize}
\item {\ttfamily geometry\+\_\+msgs\+::\+Twist turtle\+\_\+vel;}\+: This message holds the velocity commands for the turtle. The {\ttfamily linear.\+x} field holds the linear velocity, and {\ttfamily angular.\+z} holds the angular velocity.
\item {\ttfamily turtle\+\_\+vel.\+linear.\+x = linear\+\_\+x;} and {\ttfamily turtle\+\_\+vel.\+angular.\+z = angular\+\_\+z;}\+: These lines set the user-\/defined velocities for linear and angular movement.
\item {\ttfamily pub\+\_\+turtle1.\+publish(turtle\+\_\+vel);} and {\ttfamily pub\+\_\+turtle2.\+publish(turtle\+\_\+vel);}\+: Depending on the selected turtle, the program publishes the velocity message to the appropriate topic ({\ttfamily /turtle1/cmd\+\_\+vel} or {\ttfamily /turtle2/cmd\+\_\+vel}).
\item {\ttfamily ros\+::\+Duration(1.\+0).sleep();}\+: This command pauses the program for 1 second, allowing the turtle to move. {\ttfamily ros\+::\+Duration(1.\+0).sleep()} is used instead of {\ttfamily sleep(1.\+0)} because it is specifically designed for R\+OS nodes, ensuring proper synchronization with the R\+OS event loop and preventing any timing issues.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md34}{}\doxysubsubsection{3. Stopping the Turtle}\label{md__r_e_a_d_m_e_autotoc_md34}
After 1 second, the velocities are set to 0 (both linear and angular) to stop the turtle, and the stop command is published to the respective turtle.\hypertarget{md__r_e_a_d_m_e_autotoc_md35}{}\doxysubsection{4. Python $<$tt$>$turtle2$<$/tt$>$ already exist issue}\label{md__r_e_a_d_m_e_autotoc_md35}
As discussed earlier, when restarting the {\ttfamily \mbox{\hyperlink{namespaceuser__interface}{user\+\_\+interface}}} node in {\bfseries{Python}}, the node crashed because {\ttfamily turtle2} already existed in the simulation. This issue did not occur in the {\bfseries{C++}} version.

To address this problem in {\bfseries{Python}}, an additional check was implemented to ensure that {\ttfamily turtle2} already exists in the simulation before attempting to spawn it. This check uses the {\ttfamily /turtle2/pose} topic, which is only active when {\ttfamily turtle2} is present. The solution involves the following steps\+:


\begin{DoxyItemize}
\item Check if {\ttfamily turtle2} Exists\+:
\begin{DoxyItemize}
\item Subscribe to the {\ttfamily /turtle2/pose} topic, which publishes the position and orientation of {\ttfamily turtle2}.
\item If a message is received within a 1-\/second timeout, it confirms that {\ttfamily turtle2} already exists in the simulation, and no further action is needed.
\end{DoxyItemize}
\item Spawn {\ttfamily turtle2} if Not Found\+:
\begin{DoxyItemize}
\item If no message is received within the timeout, the node assumes that {\ttfamily turtle2} does not exist.
\item The node then calls the {\ttfamily /spawn} service to create {\ttfamily turtle2} at the coordinates $\ast$$\ast$(5.\+0, 2.\+0)$\ast$$\ast$ with an orientation of {\bfseries{0.\+0}}.
\end{DoxyItemize}
\end{DoxyItemize}

Below is the code that sets up this check\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{def check\_if\_turtle2\_exists():}
\DoxyCodeLine{  \#\# Checks if turtle2 exists by subscribing to /turtle2/pose.}
\DoxyCodeLine{  turtle2\_exists = False}
\DoxyCodeLine{  def pose\_callback(msg):}
\DoxyCodeLine{      nonlocal turtle2\_exists}
\DoxyCodeLine{      turtle2\_exists = True  \# Message received; turtle2 exists}
\DoxyCodeLine{  \# Subscribe to /turtle2/pose topic}
\DoxyCodeLine{  rospy.Subscriber('/turtle2/pose', Pose, pose\_callback)}
\DoxyCodeLine{  \# Short delay , wait message}
\DoxyCodeLine{  timeout\_time = rospy.Time.now() + rospy.Duration(1.0)  \# 1-\/second timeout}
\DoxyCodeLine{  while rospy.Time.now() < timeout\_time and not rospy.is\_shutdown():}
\DoxyCodeLine{      rospy.sleep(0.1)  \# Sleep in small increments}
\DoxyCodeLine{  return turtle2\_exists}
\end{DoxyCode}


\DoxyHorRuler{0}
 \hypertarget{md__r_e_a_d_m_e_autotoc_md37}{}\doxysubsection{Distance Monitor Node}\label{md__r_e_a_d_m_e_autotoc_md37}
Similar to {\ttfamily user interface} node, the {\ttfamily Distance Monitor} Node shares a similar structure in both {\bfseries{Python}} and {\bfseries{C++}}, with the core logic remaining consistent across both implementations. I will use the {\bfseries{C++}} version as the primary example to explain the implementation.\hypertarget{md__r_e_a_d_m_e_autotoc_md38}{}\doxysubsection{1. Set boundary conditions}\label{md__r_e_a_d_m_e_autotoc_md38}
In {\ttfamily turtlesim}, the window has predefined coordinates where the turtles\textquotesingle{} positions are constrained. The boundary conditions are essential to keep the turtles within the window and avoid collisions. The following conditions are defined\+:


\begin{DoxyItemize}
\item {\bfseries{boundary\+\_\+limit}}\+: This is the minimum allowed position (in both the x and y directions). If the turtle\textquotesingle{}s position gets close to this limit, it is considered near the boundary. Here it is set to 1.\+0.
\item {\bfseries{max\+\_\+limit}}\+: This is the maximum allowed position for a turtle. If the turtle exceeds this limit, it is considered out of bounds, and corrective actions should be taken. Here it is set to 10.\+0.
\item {\bfseries{distance\+\_\+threshold}}\+: This defines the minimum safe distance between the two turtles. If the turtles get closer than this distance, they are considered to be too close and need to be stopped to avoid collision. Here it is set to 2.\+0. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Global variables to store turtle positions}}
\DoxyCodeLine{\textcolor{keywordtype}{float} \mbox{\hyperlink{distance__monitor_8cpp_a386ca21344ebf1087871f54d8e89f93a}{turtle1\_x}}, \mbox{\hyperlink{distance__monitor_8cpp_af699f1ae0d9eb8f524d8820a806f1a1a}{turtle1\_y}}, \mbox{\hyperlink{distance__monitor_8cpp_a18b4c1bf1df6ad90f1e236bd496387f4}{turtle2\_x}}, \mbox{\hyperlink{distance__monitor_8cpp_aa22dc3f61e7b2c48e0761801e1f124bf}{turtle2\_y}};}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{float} \mbox{\hyperlink{distance__monitor_8cpp_aa1ac8686414dbfefaeac118fff7d3ebb}{distance\_threshold}} = 2.0;}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{float} \mbox{\hyperlink{distance__monitor_8cpp_a8fae504c5b5982cecffc3c82190a1f29}{boundary\_limit}} = 1.0;}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{float} \mbox{\hyperlink{distance__monitor_8cpp_a878bf73af4e66301337cd71ff79f622c}{max\_limit}} = 10.0;}
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md39}{}\doxysubsection{2. Calculate the distance between two turtles}\label{md__r_e_a_d_m_e_autotoc_md39}
To calculate the distance between two turtles, the {\bfseries{Euclidean distance}} formula is used. This formula determines the straight-\/line distance between two points in a 2D space based on their {\bfseries{x}} and {\bfseries{y}} coordinates. The formula is\+:

\$\$ distance = \textbackslash{}sqrt\{(x\+\_\+2 -\/ x\+\_\+1)$^\wedge$2 + (y\+\_\+2 -\/ y\+\_\+1)$^\wedge$2\} \$\$

Where\+:
\begin{DoxyItemize}
\item \$( (x\+\_\+1, y\+\_\+1) )\$ are the coordinates of turtle1,
\item \$( (x\+\_\+2, y\+\_\+2) )\$ are the coordinates of turtle2.
\end{DoxyItemize}

This calculation helps in monitoring whether the turtles are too close to each other, based on the {\bfseries{distance\+\_\+threshold}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Calculate the distance between turtles}}
\DoxyCodeLine{\textcolor{keywordtype}{float} distance = sqrt(pow(\mbox{\hyperlink{distance__monitor_8cpp_a18b4c1bf1df6ad90f1e236bd496387f4}{turtle2\_x}} -\/ \mbox{\hyperlink{distance__monitor_8cpp_a386ca21344ebf1087871f54d8e89f93a}{turtle1\_x}}, 2) + pow(\mbox{\hyperlink{distance__monitor_8cpp_aa22dc3f61e7b2c48e0761801e1f124bf}{turtle2\_y}} -\/ \mbox{\hyperlink{distance__monitor_8cpp_af699f1ae0d9eb8f524d8820a806f1a1a}{turtle1\_y}}, 2));}
\end{DoxyCode}


Now, to perform this calculation, we need the {\bfseries{x}} and {\bfseries{y}} values for both turtles. These values are retrieved by subscribing to the {\ttfamily /turtle1/pose} and {\ttfamily /turtle2/pose} topics. Each turtle continuously publishes its position in the {\bfseries{Pose}} message format, which includes the {\bfseries{x}} and {\bfseries{y}} coordinates. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Subscribers for turtle positions}}
\DoxyCodeLine{ros::Subscriber sub\_turtle1 = nh.subscribe(\textcolor{stringliteral}{"/turtle1/pose"}, 10, \mbox{\hyperlink{distance__monitor_8cpp_a9df5b194e91cee8f60bf66de6c31cc23}{turtle1PoseCallback}});}
\DoxyCodeLine{ros::Subscriber sub\_turtle2 = nh.subscribe(\textcolor{stringliteral}{"/turtle2/pose"}, 10, \mbox{\hyperlink{distance__monitor_8cpp_af8f5c80ded86165f9faaf2a529b12d01}{turtle2PoseCallback}});}
\end{DoxyCode}


{\bfseries{turtle1\+Pose\+Callback}} and {\bfseries{turtle2\+Pose\+Callback}} are callback functions that update the global position variables (turtle1\+\_\+x, turtle1\+\_\+y, turtle2\+\_\+x, turtle2\+\_\+y) whenever new {\bfseries{Pose}} messages are received from each turtle.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{distance__monitor_8cpp_a9df5b194e91cee8f60bf66de6c31cc23}{turtle1PoseCallback}}(\textcolor{keyword}{const} turtlesim::Pose::ConstPtr\& msg) \{}
\DoxyCodeLine{  \mbox{\hyperlink{distance__monitor_8cpp_a386ca21344ebf1087871f54d8e89f93a}{turtle1\_x}} = msg-\/>x;}
\DoxyCodeLine{  \mbox{\hyperlink{distance__monitor_8cpp_af699f1ae0d9eb8f524d8820a806f1a1a}{turtle1\_y}} = msg-\/>y;}
\DoxyCodeLine{  ROS\_INFO(\textcolor{stringliteral}{"Turtle1 updated position: (\%.2f, \%.2f)"}, \mbox{\hyperlink{distance__monitor_8cpp_a386ca21344ebf1087871f54d8e89f93a}{turtle1\_x}}, \mbox{\hyperlink{distance__monitor_8cpp_af699f1ae0d9eb8f524d8820a806f1a1a}{turtle1\_y}});}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md40}{}\doxysubsection{3. Check if the turtle are too close to each other}\label{md__r_e_a_d_m_e_autotoc_md40}
After calculating the distance, we use the {\bfseries{distance\+\_\+threshold}} to check if the turtles are too close. If the distance is less than the threshold, a flag is set to indicate that the turtles need attention. The following check updates the flag\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Check if turtles are too close}}
\DoxyCodeLine{\textcolor{keywordtype}{bool} is\_too\_close = (distance <= \mbox{\hyperlink{distance__monitor_8cpp_aa1ac8686414dbfefaeac118fff7d3ebb}{distance\_threshold}});}
\end{DoxyCode}


This flag can then be used to trigger any necessary actions.\hypertarget{md__r_e_a_d_m_e_autotoc_md41}{}\doxysubsection{4. Check if the turtle are near boundary}\label{md__r_e_a_d_m_e_autotoc_md41}
To monitor if the turtles are approaching the boundary, we use a boolean flag. This flag is set by checking whether either of the turtles\textquotesingle{} coordinates are nearing or exceeding the predefined boundary limits. We perform this check using the {\ttfamily \mbox{\hyperlink{distance__monitor_8cpp_ab8d39a2213dbc3a99c17f0f488f9d547}{is\+\_\+near\+\_\+boundary()}}} function, which compares both the x and y positions of the turtles against the boundary limits ({\ttfamily boundary\+\_\+limit} and {\ttfamily max\+\_\+limit}). If any coordinate is outside the allowed range, the function returns {\ttfamily true}, indicating that the turtle is near the boundary. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Check if turtles are near boundaries}}
\DoxyCodeLine{\textcolor{keywordtype}{bool} turtle1\_near\_boundary = \mbox{\hyperlink{distance__monitor_8cpp_ab8d39a2213dbc3a99c17f0f488f9d547}{is\_near\_boundary}}(\mbox{\hyperlink{distance__monitor_8cpp_a386ca21344ebf1087871f54d8e89f93a}{turtle1\_x}}, \mbox{\hyperlink{distance__monitor_8cpp_af699f1ae0d9eb8f524d8820a806f1a1a}{turtle1\_y}});}
\DoxyCodeLine{\textcolor{keywordtype}{bool} turtle2\_near\_boundary = \mbox{\hyperlink{distance__monitor_8cpp_ab8d39a2213dbc3a99c17f0f488f9d547}{is\_near\_boundary}}(\mbox{\hyperlink{distance__monitor_8cpp_a18b4c1bf1df6ad90f1e236bd496387f4}{turtle2\_x}}, \mbox{\hyperlink{distance__monitor_8cpp_aa22dc3f61e7b2c48e0761801e1f124bf}{turtle2\_y}});}
\end{DoxyCode}


The {\ttfamily is\+\_\+near\+\_\+boundary} function is defined as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool} \mbox{\hyperlink{distance__monitor_8cpp_ab8d39a2213dbc3a99c17f0f488f9d547}{is\_near\_boundary}}(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} (x <= boundary\_limit || x >= \mbox{\hyperlink{distance__monitor_8cpp_a878bf73af4e66301337cd71ff79f622c}{max\_limit}} || y <= boundary\_limit || y >= \mbox{\hyperlink{distance__monitor_8cpp_a878bf73af4e66301337cd71ff79f622c}{max\_limit}});}
\DoxyCodeLine{\}}
\end{DoxyCode}


If any of the flags (distance or boundary) are triggered, necessary actions are performed.\hypertarget{md__r_e_a_d_m_e_autotoc_md42}{}\doxysubsection{5. Perform necessary action}\label{md__r_e_a_d_m_e_autotoc_md42}
If the turtles are too close to each other or near the boundary, they need to be stopped. This is done by publishing zero velocity commands to each turtle. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// If turtles are too close or near boundary, stop them}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (is\_too\_close || turtle1\_near\_boundary || turtle2\_near\_boundary)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (is\_too\_close)\{}
\DoxyCodeLine{      \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stopTurtle}}(\mbox{\hyperlink{distance__monitor_8cpp_aca10e25faa94589e8f7dc10845abd1a0}{pub\_turtle1}});  \textcolor{comment}{// Stop turtle1}}
\DoxyCodeLine{      \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stopTurtle}}(\mbox{\hyperlink{distance__monitor_8cpp_a2beb12dd3123424a31990aebcd23133c}{pub\_turtle2}});  \textcolor{comment}{// Stop turtle2}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (turtle1\_near\_boundary)\{}
\DoxyCodeLine{      \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stopTurtle}}(\mbox{\hyperlink{distance__monitor_8cpp_aca10e25faa94589e8f7dc10845abd1a0}{pub\_turtle1}});  \textcolor{comment}{// Stop turtle1}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (turtle2\_near\_boundary)\{}
\DoxyCodeLine{      \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stopTurtle}}(\mbox{\hyperlink{distance__monitor_8cpp_a2beb12dd3123424a31990aebcd23133c}{pub\_turtle2}});  \textcolor{comment}{// Stop turtle2}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


The {\ttfamily \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stop\+Turtle()}}} function stops a turtle by publishing a {\ttfamily geometry\+\_\+msgs\+::\+Twist} message with zero velocity\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stopTurtle}}(ros::Publisher \&pub)\{}
\DoxyCodeLine{    geometry\_msgs::Twist stop\_msg;}
\DoxyCodeLine{    stop\_msg.linear.x = 0.0;}
\DoxyCodeLine{    stop\_msg.angular.z = 0.0;}
\DoxyCodeLine{    pub.publish(stop\_msg);}
\DoxyCodeLine{\}}
\end{DoxyCode}


This ensures that turtles stop moving when they\textquotesingle{}re too close or near the boundaries.\hypertarget{md__r_e_a_d_m_e_autotoc_md43}{}\doxysubsection{6. Check and handle the overshoot issue}\label{md__r_e_a_d_m_e_autotoc_md43}

\begin{DoxyItemize}
\item {\bfseries{Issue}}~\newline
 The overshoot occurs because the turtle does not stop exactly at the boundary due to delays in processing movement commands, such as timing or message delays. As the turtle approaches the boundary, the system may not react quickly enough, causing it to move past the boundary. Additionally, when reversing from the boundary, the system might incorrectly detect the turtle as too close, causing it to stop prematurely and prompt the user to input velocity conditions again. This behavior is undesirable and needs to be avoided. The issue is further exacerbated when the turtle\textquotesingle{}s velocity is too fast, as the system has less time to process the stop command and adjust the turtle\textquotesingle{}s position before it crosses the boundary.
\item {\bfseries{Solutions}}~\newline

\end{DoxyItemize}
\begin{DoxyEnumerate}
\item Limit Turtle\textquotesingle{}s Velocity~\newline
 A velocity constraint of between {\bfseries{5}} and {\bfseries{-\/5}} has been enforced. This ensures that the turtle moves at a manageable speed, allowing the system sufficient time to process movement commands and react to boundary conditions effectively. The loop rate for processing messages is set to 10 Hz, meaning the system processes 10 messages per second. By restricting velocity to this range, the turtle\textquotesingle{}s position updates occur smoothly, preventing excessive overshoot due to high-\/speed movement.~\newline
 Look at \href{\#error-handling-issue}{\texttt{ error explaination}} section above for explanation of the code.~\newline
 Even with velocity constraints, minor overshoot may still occur because of message delays or edge cases. For such scenarios, an auto-\/adjustment mechanism is suggested to be added to bring the turtle back within boundaries when overshoot is detected.
\item Auto-\/adjust Position Near Boundary~\newline
 After the turtle stops, we need to check if it has overshot the boundary. If the turtle has moved past the defined boundaries, we reposition it back within the allowed area. This is achieved by checking the turtle’s position and applying corrective velocities.
\begin{DoxyItemize}
\item Check for Overshoot\+:
\end{DoxyItemize}

We use a boolean flag to check whether the turtle\textquotesingle{}s position exceeds the defined boundary. This is done using the {\ttfamily check\+\_\+if\+\_\+overshot\+\_\+boundary} function, which checks if the current position is outside the allowable range. If the turtle’s position exceeds the boundary, we flag it as an overshoot. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool} turtle1\_overshot = \mbox{\hyperlink{distance__monitor_8cpp_a13286d6716af370899e73f9fd7634d63}{check\_if\_overshot\_boundary}}(\mbox{\hyperlink{distance__monitor_8cpp_a386ca21344ebf1087871f54d8e89f93a}{turtle1\_x}}, \mbox{\hyperlink{distance__monitor_8cpp_af699f1ae0d9eb8f524d8820a806f1a1a}{turtle1\_y}});}
\DoxyCodeLine{\textcolor{keywordtype}{bool} turtle2\_overshot = \mbox{\hyperlink{distance__monitor_8cpp_a13286d6716af370899e73f9fd7634d63}{check\_if\_overshot\_boundary}}(\mbox{\hyperlink{distance__monitor_8cpp_a18b4c1bf1df6ad90f1e236bd496387f4}{turtle2\_x}}, \mbox{\hyperlink{distance__monitor_8cpp_aa22dc3f61e7b2c48e0761801e1f124bf}{turtle2\_y}});}
\DoxyCodeLine{\textcolor{keywordtype}{bool} \mbox{\hyperlink{distance__monitor_8cpp_a13286d6716af370899e73f9fd7634d63}{check\_if\_overshot\_boundary}}(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y)\{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (x > \mbox{\hyperlink{distance__monitor_8cpp_a878bf73af4e66301337cd71ff79f622c}{max\_limit}} || x < boundary\_limit  || y > \mbox{\hyperlink{distance__monitor_8cpp_a878bf73af4e66301337cd71ff79f622c}{max\_limit}} || y < \mbox{\hyperlink{distance__monitor_8cpp_a8fae504c5b5982cecffc3c82190a1f29}{boundary\_limit}} )\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{\} }
\end{DoxyCode}

\begin{DoxyItemize}
\item Handle Overshoot\+:
\end{DoxyItemize}

Once the overshoot is detected, we adjust the turtle’s position by applying corrective velocities to bring it back inside the defined boundary.
\end{DoxyEnumerate}

{\itshape {\bfseries{Note\+:}}}
\begin{DoxyItemize}
\item I have decided to remove the implementation that attempts to correct the overshoot issue. While the logic was working as intended, it introduced other complications during testing. Rather than submitting something unreliable, I have chosen to provide a more stable solution that ensures functional behavior. The current implementation checks for overshoot occurrences and notifies the user with a warning when an overshoot is detected. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} (turtle1\_overshot)\{}
\DoxyCodeLine{    ROS\_WARN(\textcolor{stringliteral}{"Turtle1 is over the boundary after stopping!"});}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (turtle2\_overshot)\{}
\DoxyCodeLine{    ROS\_WARN(\textcolor{stringliteral}{"Turtle2 is over the boundary after stopping!"}); }
\DoxyCodeLine{\}}
\end{DoxyCode}

\item The {\bfseries{C++}} {\ttfamily distance monitor} node had some wonky logic to handle overshoot near simulation boundaries. It mostly worked but introduced a few complications, which is why I decided to remove it.\+This logic has been commented out to keep things simpler, but it is still in the source for reference.
\item Additionally, the overshoot issue can also arise when the turtles get too close to each other. Similar to overshoot near boundaries, here, I have only implemented a check to alert the user when the turtles are way too close in proximity (i.\+e., below a predefined distance threshold). Further action to address these behaviors can be programmed at a later stage. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} (is\_too\_close)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{      \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stopTurtle}}(\mbox{\hyperlink{distance__monitor_8cpp_aca10e25faa94589e8f7dc10845abd1a0}{pub\_turtle1}});  \textcolor{comment}{// Stop turtle1}}
\DoxyCodeLine{      \mbox{\hyperlink{distance__monitor_8cpp_a2b590ca78ab10ef0c89adb2da9a86e21}{stopTurtle}}(\mbox{\hyperlink{distance__monitor_8cpp_a2beb12dd3123424a31990aebcd23133c}{pub\_turtle2}});  \textcolor{comment}{// Stop turtle2}}
\DoxyCodeLine{      \textcolor{keywordtype}{float} distance = sqrt(pow(\mbox{\hyperlink{distance__monitor_8cpp_a18b4c1bf1df6ad90f1e236bd496387f4}{turtle2\_x}} -\/ \mbox{\hyperlink{distance__monitor_8cpp_a386ca21344ebf1087871f54d8e89f93a}{turtle1\_x}}, 2) + pow(\mbox{\hyperlink{distance__monitor_8cpp_aa22dc3f61e7b2c48e0761801e1f124bf}{turtle2\_y}} -\/ \mbox{\hyperlink{distance__monitor_8cpp_af699f1ae0d9eb8f524d8820a806f1a1a}{turtle1\_y}}, 2));}
\DoxyCodeLine{      \textcolor{keywordflow}{if} (distance < \mbox{\hyperlink{distance__monitor_8cpp_aa1ac8686414dbfefaeac118fff7d3ebb}{distance\_threshold}})\{}
\DoxyCodeLine{          ROS\_WARN(\textcolor{stringliteral}{"Turtles are really too close !!!"});}
\DoxyCodeLine{      \}\}}
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md44}{}\doxysection{Summary}\label{md__r_e_a_d_m_e_autotoc_md44}
The current implementation successfully meets the main objectives of the assignment with a well-\/structured approach.

The {\ttfamily user interface} node performs key tasks smoothly\+: spawning {\ttfamily turtle2}, allowing users to select which turtle to control, and setting both angular and linear velocities. It also checks and handles invalid user input, ensuring the system remains robust and reliable. The node moves the turtles for one second based on the input, stops them, and then prompts the user for further commands.

Similarly, the {\ttfamily distance monitor} node efficiently handles the required tasks. It ensures turtles stop at designated boundaries and prevents collisions by halting them at a defined distance threshold. Although handling of overshoot and boundary issues has been removed for now, the program still includes basic checks for overshoot, notifying the user when it occurs or when the turtles are too close to one another.

Overall, the solution is stable and reliable in its current form, but there is potential for future improvements and optimizations. Areas for enhancement include refining the distance monitoring system, improving overshoot handling, and integrating more advanced features to offer better control and flexibility in managing turtle interactions. 